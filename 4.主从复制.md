#主从复制

----

主从复制有很广泛的应用，如GFS的chunk server。但是今天我们的主题是学习VM-FT，以及理想中的“强一致性”。

##容错
我们希望无论遇到哪种类型的故障，系统都能够继续服务。
强一致性是指 GFS就像一台服务器一样能够一直提供有效的文件服务，虽然这很难，但在实践中很有用。

##故障模型
我们需要一个故障模型，如何时需要尝试拷贝数据。

* VM-FT(虚拟机的容错机制)假定同一时间只有一个故障发生，且是失败停止的计算机故障。
* 站点范围的电力故障（最后会重新启动）
* 网络分隔
* 无bug、无恶意代码

##核心思想：复制

* 首先，需要两个或两个以上的服务器，每个副本保存提供服务所需的状态，如果一个副本发生故障，其他的服务器可以继续运行，提供服务。

* 例如：MapReduce中master的容错，lab1中worker已经有了容错机制，但master只有一个，称之为“故障单点”。若要增加到两个master，一个发生异常时，需要保持master的状态。如：worker列表、已经完成的任务、worker的运行状态、TCP连接状态、程序计数器等等。

**需要考虑的问题**

* 哪些是需要复制的状态
* 副本如何获取状态
* 何时转换到备份服务器
* 在转换时是否会发生异常
* 如何在修复/重新整合后提供服务

**两个主要方法**

* 状态传输：主备份复制执行服务，主服务将新状态发送给从服务器
* 复制状态机：所有副本执行相同的操作，如果从同一状态启动，并以相同的顺序执行相同的确定性操作，那么结束时的状态也是相同的。
* 传递状态很容易，但是状态的数据量可能很大，传输速度较慢。VM-FT使用了复制状态机的方法。复制状态机效率更高，这是因为操作所需的数据量相比数据来说更小，但复杂性是不会变的。例如，多核操作的顺序，确定性操作。


**复制状态机**

* K/V的put和get
* x86架构
* 影响性能，但容易实现。主从之间需要多少交互。高层次抽象机
* 高层次的抽象机可以传输更少信息
* 处理x86上的非确定性操作很难，对于put/get还是比较容易的
* x86 RSM可以执行所有x86程序

##VM-FT

* 整个系统级别的复制
* 对应用和client完全透明
* 为所有软件提供高可用性
* 系统工作的很好
* 故障模型：独立的硬件故障、站点范围的电力故障
* 只限于单处理器的VM，多处理器涉及了很多非确定性的操作，同步起来效率较低。


**总览**

* 整体架构为：app，O/S,底层VM-FT
* 两台主要机器：主服务器和从服务器，以及其他机器
* 两个网络：客户端到服务器，日志通道
* 共享的持久化存储硬盘
* 主从服务器步伐一致，主服务器将所有输入发送给备份服务器，备份服务器的输出被丢弃掉，只使用主服务器的输出
* 在主从之间通过“心跳”保持连接，如果主服务器崩溃，从服务器接管服务
* 输入有哪些？时钟中断、网络中断、硬盘中断

**面临的挑战**

1. 如何使整个系统看起来像是一个单独可靠服务器？主服务器崩溃时从服务器接管服务，外部世界是否能够察觉到变化？若主服务器在返回响应给client的前后崩溃，client的请求是否会丢失？是否需要再次执行？主服务器何时向client发送响应？
2. 怎么避免有两个主服务器（精神分裂综合征）？如果logging channel中断时系统如何处理？主从是否都会变为主服务器
3. 如何对主服务器进行准确的备份？主服务器的哪种操作需要发送给从服务器？如何处理非确定性的操作？例如：主服务器的中断必须以相同的指令传递给从服务器。

###问题一解决方案:确定性的回放

* 目标：使x86平台变得具有确定性。思路：使用hypervisor（超级管理者）使虚拟的x86平台具有确定性。分为两个阶段：记录日志和日志回放。
* 记录所有的硬件事件，如时钟中断，网络中断，I/O中断等。对非确定性指令来说，需要记录额外的信息。如记录寄存器某个时间戳的值。在回放时，返回日志中的值而非寄存器中的值。
* 回放：将输入以相同顺序的指令传递。如果在记录过程中，第N条指令时收到了时钟中断，那么在回放时也在第N条指令传递中断。
* 给定一个事件的日志，确定性回放可以重建VM。hypervisor发送第一个事件，vm收到后执行，使用特殊硬件寄存器 在执行指令时可以暂停处理器
* 回放过程中，虚拟的x86会执行与记录日志的vm相同的操作。OS运行相同，APP也相同。回放的输出结果也相同。
* 限制：不能处理x86多核处理器，记录和回放多核中交错的指令的代价十分昂贵。
* 确定性回放的应用：Hypervisor在primary记录日志，通过logging channel将其发送给从服务器。
* 从服务器回放时，在下个事件指令执行之前需要停止x86虚拟机，从服务器比事件要慢一些。

**例子**

* 主服务器接收到网络中断，hypervisor将中断的数据发送给从服务器
* hypervisor将网络中断传递给操作系统内核
* 操作系统执行中断
* 内核将包发给服务器，服务器将响应发给网卡
* hypervisor获得控制并将响应发给网络
* 从服务器收到日志并传递网络中断
* hypervisor将网络中断传递给操作系统内核
* ......
* 服务器内核将包发给服务器，服务器将响应发给网卡
* hypervisor获得控制，但不会将响应发给网络
* hypervisor忽略本地时钟中断
* 主从服务器获取相同的输入，以相同的状态结束

**容错协议**

* 主服务器计算出输出后延迟返回，直至收到服务器的ACK。日志记录了所有输出过程中操作，主服务器在从服务器收到输出操作日志的确认后，向外部返回输出。
* 性能优化：主服务器保持运行，缓存输出，收到从服务器确认后返回

为什么需要发送输出事件给从服务器并在收到确认后才返回？
注意：不要记录输出事件，只记录输入事件。
主服务器：处理网络输入-产生输出-主服务器发生故障。由于发生故障，从服务器不能正确复制执行这个序列。从服务器最后的日志是：处理网络输入，将其传递给内核；从服务器转为“live”状态，接管服务，成为主服务器。
主服务器发生硬件中断，如时钟中断。hypervisor将中断传递给内核。从服务器此时不知道主服务器是否已经产生了输出，因为其没有中断的日志也没有输出的执行日志。时钟中断可能会影响输出。通过给从服务器发送初始的输出事件，从服务器可以正确执行事件。


主服务器和从服务器是否会产生相同的输出事件？
答案是确定的。主服务器向从服务器发送初始的输出事件，计算输出，然后发送故障。从服务器声明主服务器已经发送故障，回放初始的输出事件，接管服务，执行输出事件。

作者指出产生两次输出并不是问题，如果输出是网络包，client必须能够处理重复的数据包。若输出是写到磁盘，则会向相同的位置写入相同的数据两次,由于不会在两次写入期间写入其他数据，因此也没有问题。如果输出是从磁盘读取，将相同位置数据读入两次也没有问题。


当主服务器发生故障时，收到了网络输入但还未发送日志给从服务器，此时该如何处理？
网络输入，依赖于客户端的重试机制，这是合理的，因为网络在传输过程中也会丢失数据包。
磁盘输入，hypervisor重启等待中的磁盘I/O


###问题二解决方法：共享磁盘
论文的解决方法：共享磁盘

从服务器回放最后的日志，并自动测试和设置磁盘上的变量。
如果设置成功，说明主服务器还处于运行状态。如果设置失败，主服务器已经不可用，从服务接管，成为主服务器。如果是主服务器，使用VMotion根据checkpoint创建从服务器。

共享存储是一个故障单点，如果共享存储发生故障，那么服务就会变得不可用。

为什么主服务器上的日志不记录在共享磁盘？优点：不需要logging channel，不需要FT协议等等

主服务器发生故障后，需要多久恢复服务？需要的步骤：检测故障、执行日志、在VM-FT机制下，如果从服务器比主服务器慢很多，那么也会被拖慢主服务器。


**总结**
* 主从例子：VM-FT
* 如何处理多个主服务器（下节介绍）
* 怎么优化性能：主从复制使用高层次的复制状态机
# 最终一致性

最终一致性是分布式计算系统中使用较多的一种一致性模型，该模型可用于保证高可用性。与传统的ACID(Atomicity原子性, Consistency一致性, Isolation隔离线, Durability持久性)相比，由于强一致性很难到达，分布式系统通常使用BASE(Basically Available 基本可用, Soft state软状态, Eventual consistency最终一致性)。 

##总览

本节的主题是松弛一致性（弱一致性？），Bayou论文内容是关于“最终一致性”的。在以下情形中，我们会用到最终一致性：

* 多副本、快读本地读写、副本同步
* 在网络连状态不佳的情况下

最终一致性中，应用最初只写入本地副本，所以应用和用户有可能会看到不同内容的副本。某些并发的写可能造成冲突时，我们需要解决这些冲突。
最终一致性是很常见的一种一致性模型，如git、iPhone同步、Dropbox和Amazon Dynamo都使用了最终一致性。Bayou有最复杂的协调同步过程。

###论文背景

在90年代早期，PDA、笔记本电脑和平板电脑刚刚出现，虽还很笨拙，但有很大的潜力；当时还没有遍地的无线网络（WIFI还没有出现），网络连接也很差。当然，即便是在今天，虽然网络已经十分发达，我们也不能保证100%的网络连通性。

下面，我们看一个会议房间调度程序的例子，调度程序有如下要求：

* 同一时间段，一个房间只允许有一个会议
* 每条日志包含会议的时间和描述
* 每个用户看到的记录集是相同的

###传统的方法

只设置一台服务器；服务器同一时间只处理一台client的请求，服务器检查请求的会议室的时间安排是否发生冲突，返回成功或失败；之后，更新数据库，处理下一个请求；服务器对于并发请求会隐含的为其选择执行顺序。

传统的方法在以下情况，并不能让人满意。

* 比如用户想要在一台未连接网络的iphone上使用调度程序，因此每个节点上都需要数据库的副本，任何节点上都可以读写。
* 节点断断续续连接到网络
* 节点之间进行通信不佳（如蓝牙）


**解决方法：合并数据库**

允许所有设备对同步自己的本地数据库。在同步时，比较数据库，查找不一致的记录，尝试接受其他设备的更新。因此，我们需要一种机制来处理发生冲突的记录。比如，同一时间有两个会议的情况。用户可能不能决定合并数据库的时机，因此需要系统自动解决冲突。分布式系统中，有很多解决冲突的方法，例如使用最近的更新，忽略其他记录。但是在日程表系统中，我们不想只是简单删除用户的日程安排。

**解决冲突：应用提供更新函数**

在写操作时，可以让应用提供一个冲突处理函数用于解决冲突（不只是提供一个新的值）。该冲突处理函数读取数据库，决定如何最好的更新数据库。例如函数在命名冲突时可以读取数据库，获取count后进行累加，从而解决冲突。
再例如，冲突处理函数的逻辑可以是：如果9点会议室空闲则开会，否则推迟到10点，若10点也有安排则推迟到11点。函数可以为离线用户做出协调决定。同步时交换函数，而非数据库内容。


###问题：冲突时不能只是运行更新函数

A：工作人员在10点或11点开会
B：雇员在10点或11点开会
X先同步A的写入，然后再同步B
Y先同步B的写入，然后再同步A

由于同步的顺序不同，会发生这种情况，X会将A会议放在10点，Y将A会议的放在11点。这就达不到我们的目标。
我们目标是：最终一致性，即X和Y最初不一致，但经过足够时间的同步后，所有节点的数据库应该是一致的。

**方法：顺序化更新日志**

每个节点将更新日志顺序化，同步时保证节点有相同的log（相同的更新，相同的顺序）；并且数据库是按照顺序应用更新函数的结果。这样可以保证：

相同的日志=>相同的顺序=>相同的数据库内容

注意，我们依赖于两个状态的相等：

* 数据库和日志操作；
* 库也使用相同的方法。

**如何确定更新顺序？**

我们可以在每个记录初始创建时为其分配时间戳：
Timestamp: <T, I>
T是创建记录时的节点时钟；I是创建记录的节点ID。

顺序更新a和b：
 若 a.T < b.T 或 (a.T = b.T and a.I < b.I)时a < b
 
 
例子：
<10,A>: 工作人员10:00或11:00开会
<20,B>: 雇员10:00或11:00开会
使用时间戳顺序执行更新函数的的结果是工作人员10点开会，雇员11点开会

在同步之前，A节点数据库的内容是工作人员10:00开会，B的内容是雇员10点开会

现在A和B开始同步：每个节点按照时间戳排序新的记录，加入到自己的log；那么所有节点都知道更新的集合；A可以只执行B的更新函数，B已经执行了B的操作，不需要再执行。

**回滚和重执行**

上面的例子中，B收到<10,A>的日志，该日志在B的<20,B>之前，因此B需要回滚数据库，重新以正确的顺序执行日志。日志保存了真相，而节点数据库只是当时的最优选择。

同步后数据库将会最终达到一致。如果每个节点已经充分同步，同时所有节点不创建新的更新，那么每个节点的数据库的内容是相同的。这是因为时间戳定义了一个总的顺序，使得更新是确定的。


我们现在知道了如何解决冲突，初始时A=foo，B=bar；一台设备：从A拷贝到B，其他设备：从B拷贝到A；通过dependency check和merge procedure，可以使得所有节点的最终结果保持一致？
 
 
**更新顺序与时钟时间一致吗？**
 
不一定。
A可能会先执行，其时间戳是<10,A>；由于节点的时钟并是完美的同步，可能导致B执行时的时间戳是<9,B>
那么B的会议获得优先级，即使A首先进行的请求。这不是外部一致性。

**更新顺序和因果是一致的吗？**

不一定。
如果A添加会议，然后B看到A的会议，然后B删除了A的会议。
有这种可能：<10,A>添加，<9,B>删除--B的时钟慢，现在删除会在add之前。

**Lamport逻辑时钟解决因果一致性**

若节点观察到E1，然后生成E2，则TS(E2)>TS(E1)
这样节点会以顺序E1-E2执行

Lamport时钟：
Tmax = 所有节点可见的最高时间戳
T = max(Tmax + 1, wall-clock time) 产生时间戳

注意：
在相同节点上E1比E2早 => 
TS(E1) < TS(E2)，
但是TS(E1) < TS(E2) 并不意味着E1先于E2。

逻辑时钟解决上面add/delete因果一致性问题：
当B看到<10,A>,B将会设置Tmax为10;并生成<11,B>用于删除，这样可以保证delete在add之后。

###其他问题

令人烦恼的是较低时间戳的更新总是伴随着较长时间的延迟；这会导致后续的更新修改最终结果。用户不能确保会议时间是最终确定的，写操作时的日志只是尝试性的。

我们希望看到的结果是每个更新最终变为稳定的。
=>更新顺序不会发生变化
=>固定写入函数的影响，如会议时间不会改变
=>不是必须能回滚，重新运行已提交的更新

**方法：一个完全去中心化的“提交”协议**

若节点看不到TS<=10的更新，那么<10,A>是稳定的。一旦节点从任何其他节点看到TS>10的更新，则不会再处理TS<10的更新，然后可以确保<10,A>是稳定的。但Bayou没有使用去中心化的提交协议。

**Bayou使用的方法**

将一个节点指定为主副本；其对收到的每个更新操作都设置一个提交序列号CSN(Commit Sequence Number);一个完整的时间戳是<CSN,本地时间,节点ID>，未提交的更新在所有已提交的更新之后；节点之间的CSN的通知是同步的。

commit/CSN协议最终会确保稳定性。一旦主副本分配CSN为10，那么不会再分配更低的CSN。因此一旦更新有了CSN，则之前的更新是稳定的。

提交顺序与试验顺序通常是一致的。同步时以日志顺序发送，包含从其他节点获取的更新。因此，如果A的更新日志是
<-,10,X>
<-,20,A>
A会将这些更新以这个顺序发送到主副本，主副本会按照顺序分配CSN，提交顺序会与暂定的顺序一致。

但提交顺序与暂定顺序不一定一直相同，因为主副本可能在看到旧数据之前看到最新的更新，看下面的例子。

A <-,10,A> W1
B <-,20,B> W2

如果此时C看到了两个更新，C的顺序是:W1 W2
B同步主副本，W2获得CSN=5，之后A同步写主副本，W1获得CSN=6；当C同步时，顺序会变为W2 W1
<5,20,B> W1
<6,10,A> W2
因此，commit可能改变顺序。
commit使得应用可以告诉用户哪个日程记录不会修改。

节点可以丢弃日志已提交的更新，相反的，也可以保持一份最高已知的CSNd的数据库的拷贝。当重新执行暂定更新日志时，会回滚数据库。

如果节点丢弃了日志后如何同步？假设A节点丢弃了所有有CSN的更新，保存了一份稳定数据库的副本。当我将其传播到接口X时，如果X最高的CSN比A的小，则A可以发送其稳定的数据库副本给X，X可以使用该DB作为起始点,X可以丢弃所有的CSN日志，然后将其暂定的更新重新执行到数据库中。
若X最高的CSN比A的大，则X不需要A的DB.

在实践中，Bayou节点保存最后若干个提交的更新，用来在同步时避免发送整个DB。


**如何同步**

A发送到B，需要一个方法能够使得B很告诉A需要发送哪些数据。已commit的更新很容易，B将自己的CSN发送给A。对应暂定的更新，如：

```
A :
    <-,10,X>
    <-,20,Y>
    <-,30,X>
    <-,40,X>
B :
    <-,10,X>
    <-,20,Y>
    <-,30,X>
```

同步开始时，B通知A “X 30，Y 20”。例如，对于每个节点，可以看到B最高的TS。同步的属性意味着B有30之前所有关于X的更新，20之前所有Y的更新。
A发送所有<-,30,x>之后的更新，已经所有<-,20,y>之后的更新给B。
这是一个汇总了日志内容的版本向量(version vector)，即论文中图4中的'F'向量。
A中的 F: [X:40,Y:20]
B中的 F: [X:30,Y:20]


###加入和退出

我们向系统加入新的服务器节点Z。

Z离开系统时，我们需要在VV中除去Z。我们可以通过以下方法确认Z已经退出系统：
Z发送更新<-,?,Z>用来通知离开系统。若节点看到“退出”的更新，将Z从V-V中删除。

如果A的V-V中有从Z获取的日志，但B的VV中没有Z的日志。例如：A有<-,25,Z>，B的V-V是[A:20,B:21]。这种情况有可能是：Z可能已经退出，B知道，A不知道；Z是新的，A知道，但B不知道。我们需要一种方法清除这种歧义。

**Bayou的退出方法**

Z通过与服务器X联系加入系统，将Z的ID指定为<Tz,X>,其中Tz是Z加入时X的逻辑时钟；X发出<-,Tz,X> ，通知有新服务器加入，其ID是<Tz,X>

ID=<Tz,X>的方法可以帮助确认是新加入的还是遗漏的。假设Z的ID是<20,X>,A同步到B，A有来自于Z的更新日志<-,25,<20,X>>,B的V-V没有Z的记录，即B没有看到过Z，或者已经看到Z退出系统。

一种情况：
B的VV：[X:10,...]
10<20 意味着B没有看到X中最新的Z
另一种情况：
B的VV: [X:30, ...]
20<30 意味着B一旦知道了Z的存在，但看到了退出。


##总结

* 通过同步和时间戳顺序达成最终一致性。
* 通过Lamport时间戳确保因果一致性
* 通过主服务器分配CSN确保稳定性
* 通过写函数的日志解决冲突
* 通过版本向量(Version Vector)进行快速的日志对比
* 通过node的ID方法在服务器退出时从VV中删除


* 无连接/弱连接操作通常是昂贵的，如iPhone同步，Dropbox，git，Dynamo，Cassandra等等
* 最终一致性可以看到未连接时的操作，
* 未连接的读写副本会导致更新冲突
* 解决冲突的方法可能需要由应用来指定。




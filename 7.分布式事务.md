# 分布式事务

---

    本节的主题是分布式事务和两阶段提交。分布式事务=分布式提交+并发控制
    
##分布式提交
多台计算机合作完成某一项任务，如银行转账时需要多个子系统协作进行金额变更。每台子系统的计算机有不同的角色，例如，转出账户的系统和转入账户所在系统。分布式事务需要确保原子性：所有操作要么都执行，要么都不执行。分布式事务面临的问题：容错和性能。
    
###例子：日程系统
假设每个用户有一个日程表，开会时则需要协调多个与会者，使其日程表达成一致，否则就不能开会。例如一台服务器保持用户A-M，其他服务器保存N-Z。
```
sched(u1, u2, t):
    begin_transaction
      ok1 = reserve(u1, t)
      ok2 = reserve(u2, t)
      if ok1 and ok2:
        commit
      else
        abort
    end_transaction
```
通过RPC调用两台服务器的reserve()，（注意：这里不是Thor，只是一个更加传统的设计）。本例中我们需要的原子性是指：是要么reserve()都执行，要么没有reserve()执行。若第一个reserve()返回true，第二个reserve()返回false（日程不可用）或没有返回(RPC消息丢失或服务器发生故障)；或者客户端在第二个reserve()执行前发生故障，那么这个事务不会提交。
在需要多个系统协作作出决定时，我们需要一个“分布式提交协议”

###思路1：先临时修改，稍后提交或回滚（或退出）
```
reserve_handler(u, t):
    if u[t] is free:
      temp_u[t] = taken -- A TEMPORARY VERSION
      return true
    else:
      return false
commit_handler():
    copy temp_u[t] to real u[t]
abort_handler():
    discard temp_u[t]
```

###思路2：使用单个实体决定是否可以提交事务
只使用一个实体可以有效的防止分歧，我们将其称为Transaction Coordinator（事务协调者-TC）。
整个流程为：client使用RPC向A,B发送请求，client向TC发送prepare请求，在end_transaction时，client向TC发送“go”。TC/A/B共同执行分布式提交协议，TA向client返回“commit”或“abort”。

###属性
分布式提交协议需要两个属性：

*   正确性，若有任何abort，不会提交
*   性能

###二阶段提交
我们开发了一种分布式事务：“两阶段提交”，分布式数据库使用其来处理多机事务。

**流程**

两阶段提交提交（无故障）：

* client向A，B发送reserve() RPC，A、B执行reserve_handler()
* client向TC发送“go”，
* TC向A和B发送“prepare”消息，A和B的响应意味着他们是否会提交。若未发生故障会返回“YES”。如果A和B都返回“yes”，TC发送“commit”消息，如果其中一个返回了“no”，TC发送“abort”消息。若A/B收到“commit”则提交（commit_handler（）最后修改用户的日历）。

上述流程说明了为什么正确性很难，除非两者都同意，否则事务无法提交。


**故障**

* 网络发生故障、损坏或者很慢
* 服务器发生故障
* 发生故障后能够正确恢复
* 超时

**消息等待**

* TC等待yes或no
* A和B等待prepare、commit、abort

**超时**

* TC等待A/B响应超时，TC不会发送任何“commit”消息，所以TC可以安全的退出并发送“abort”消息。

* A/B等待TC的prepare信息超时，由于还未收到prepare的响应，所以TC不会决定commit，因此A/B会单方面abort，之后的prepare会返回“no”

* A/B等待TC的commit/abort超时，我们以B为例（A与B情况相同）。若B返回“no”，则其可以单方面决定TC abort。若B返回“yes”，则还需要等待A的返回才能做出决定。因此B需要阻塞直到TC做出决定。

* 若B发生故障并重启，若B在故障之前发送了“yes”，那么B必须将结果持久化保存起来，重启后获取保存的结果。 这是因为TC可能已经收到了B的“yes”并通知A去commit。

* 如果TC发生故障并重启？如果TC在发生故障之前已经发送了“commit”或“abort”，必须将结果记录在磁盘中。A/B/client未收到响应时会重新向TC发出请求，TC重启后需要恢复复之前响应的数据。因此TC必须在发送commit消息之前，将命令持久化保存。也就是说由于A/B/Client可能已经响应了TC的请求，因此TC不能修改其故障前的响应。

**二阶段提交特点**

* 所有的主机协同合作作出最终的决定
* 所有参与者都返回“yes”才会commit
* TC发送故障会使其他服务阻塞，恢复后解除

##并发事务

并发事务，我们通常要求并发事务能够原子性提交。例如：x和y是银行余额，都是$10,。
T1事务是从y给x转$1：
```
T1:
    add(x,1)    --  server A
    add(y,-1)   --  server B
T2:
    tmp1=get(x)
    tmp2=get(y)
    print tmp1,tmp2
```
如果T2在通过RPC调用的两个add()之间执行，T2会打印11,10，这时会凭空出现多出的$1。T2能够打印的值只有10,10或者11,9

**串行化方法**

事务使用相同的顺序执行，比如先执行T1，再执行T2，或者先T2，再执行T1，两者顺序不同，但结果是相同的。

我们可以通过找出是否有串行顺序的执行结果来测试是否可以串行化。可串行化对开发者来说是很有用处的，并行事务不会互相影响。因此，如果T3和T4不发生冲突，无论哪个先执行，T3||T4并行执行的结果都是相同的。

**两阶段锁**

两阶段锁是实现可串行化的一个方法：每个数据库记录一个锁，即存有操作涉及数据的服务器保存锁，每个将操作数据的用户需要等待锁并获取锁后才能进行操作，因此add()处理方法意味着当使用x和y时需要先获得锁，锁在commit或abort后会释放。

为什么我们不能在操作数据后立刻释放锁，而要等到commit或abort后才释放？这是因为T2可能会在第一个get()后释放锁，T1在T2的两个get()之间执行，T2可能会打印10，9，这会造成T1和T2非串行化执行。

锁的作用：当事务冲突时，锁可以延迟其中一个事务使其串行执行。当事务未发生冲突，锁允许并行执行以提高性能。

锁与两阶段提交
服务器在处理客户端请求时必须获取并记录锁，因此client->server 的RPC有两个作用：获得锁，使用数据。
服务器在故障和重启之间必须保存prepared阶段事务的锁，即收到prepare请求时需要将锁记录在磁盘上。但重启后，对应非prepared事务可以释放锁（因为会对TC返回“no”）。

##两阶段提交

当一个事务需要使用多台数据库片上的数据时需要使用二阶段提交事务。
缺点是：
* 由于需要多个阶段的消息交互，因此速度较慢
* prepare/commit阶段会保持锁，因此其他事务会阻塞
* TC发生故障时可能导致一直阻塞（由于持有锁）

因此，通常在很小的范围内使用，例如：非银行，非航空公司等等。
目前的一个研究热点是开发更好的事务策略。

**与Raft**

Raft和两阶段提交解决的是不同的问题：

* 使用Raft通过副本获得高可用性，当一些服务器发生故障时，系统依然可用；Raft的多个服务器做相同的事情。
* 使用2PC时，不同参与者做不同的事情，每个服务器只执行自己需要的操作。
* 2PC并不会提高系统的可用性
* Raft不保证所有服务器都可执行操作，只需要多数工作即可。

如果需要高可用和分布式提交，每台“服务器”需要是一个Raft的多副本服务器，TC也应该是Raft多副本。
在这些多副本服务之上再执行两阶段提交，才可以实现高可用和分布式提交。

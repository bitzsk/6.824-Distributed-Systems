# 分布式乐观并发控制

---

今天的论文是：Efficient Optimistic Concurrency Control using Loosely Synchronized Clocks, by Adya, Gruber, Liskov and Maheshwari.
    
学习这篇论文的目的在于帮助程序设计者实现高效的分布式事务。Thor使用本地缓存和非锁消息机制，并通过乐观并发控制(OCC)提升性能。

##总览

```flow
st=>start: client

op1=>operation: client cache
sub1=>subroutine: My Subroutine
cond=>condition: Yes or No?
io=>inputoutput: servers(A-M N-Z)
st->op1->io
```
数据在服务器之间共享，代码在client执行，client 读取或设置服务上的对象（数据库的记录）。
client在本地缓存数据，以便可以快读读取。如果命中缓存，client不需要与服务器交互（不需要请求server）；若client未命中，从服务器拉取数据。

client缓存数据的机制会使事务面临更多困难，例如：如何避免读取过期的缓存数据？如何进行并发控制（client不会锁住）？

论文中提供的方法是：

* 可串行化：并发执行的事务结果与分别串行执行事务的结果相同，则称为可串行化。可串行化是英文直译，更准确的词可以是“串行等价的”。
* 并发冲突控制：两个并发事务使用相同记录，最多只有一个能够执行写操作。

###OCC：乐观并发控制
OCC（optimistic concurrency control ）的思路来源于1980年代，client只读写本地的缓存数据，提交之前不需要担心并发。当事务需要提交时：

* 将读写信息发送到服务器进行校验，由服务器来决定是否可以commit（若找到可串行化的串行顺序则可以commit）。如果可以commit，更新服务器的数据，向client发送作废相关缓存的请求；如果不能commit，事务退出，忽略写操作。
* 乐观锁是指因为执行时不需要担心是否可以串行化
* 与乐观锁不同，悲观锁在串行执行中每次都需要锁住进行检查

###校验算法
校验算法查看已提交的和正在提交的事务读写的对象，以此来决定是否可以得到一个可串行化顺序（即并发执行结果与实际串行执行的结果相同）。
OCC算法有很多种，Thor和FaRM采用了不同的校验算法。 

**算法1**

下面描述的算法只是一个思路，实际的校验算法不会使用‘值’进行校验。

* 一台校验服务器
* client通知校验服务器其读写的‘值’，每个将要提交的事务都可以看到该值。
* 校验服务器必须做出决定：该事务是否可以提交，即：并发的事务是否是可串行化的。
* 该算法检查所有事务，查找串行顺序：要求每个read可以看到最近一次写入的值，如果存在串行顺序，说明是可串行化的。

**算法1实例**

* 初始时，x=0 y=0 z=0，client的缓存中也都为0
* 事务并发读写后提交服务器：
  T1: Rx0 Wx1 （T1读取到的x时0，设置x为1）
  T2: Rz0 Wz9
  T3: Ry1 Rx1
  T4: Rx0 Wy1
* 校验算法需要判断读此次并发事务读写的结果是否与某个串行执行顺序的结果相等。
* 我们可以找到一个顺序:T4,T1,T3,T2(T2的顺序可以随意变换)，因此校验算法会返回成功。(T4读取到了x=0，需在T1写入之前，T3读到了T1的写入，需要在T1之后，T2读写z，与其他事务无关，位置可以随意放置，不影响结果)
* 注意：这个算法与Thor的算法的区别很大。该算法允许事务看到其他未提交的写入，这是由于四个事务并发执行，且校验期间事务不会提交。因而其可以看到每个事务的写入。

OCC由于在client端缓存了事务读写的数据且不需要锁，因此可以运行的很快。每个事务的校验只需要一个消息交换，而不是每条记录需要一个锁。OCC对于T2来说是一种很好的算法，因为T2不会与其他的任何事务发生冲突。T1 T3 T4之间有读写冲突。


**算法1，实例2**

* 初始时缓存中，x=0 y=0 
* 三个事务并发读写后提交服务器：
  T1: Rx0 Wx1
  T2: Rx0 Wy1
  T3: Ry0 Rx1
* 下面是根据读写内容推导的串行顺序：
  T1 -> T3 (via x)
  T3 -> T2 (via y)
  T2 -> T1 (via x)
这里面有一个环，因此不会产生串行顺序。否则T3可能会读到过期的数据y=0；或者T2读到过期的x=0。
在这个例子中，校验算法可以中止其中一个事务执行，然后其他的事务可以继续commit。例如 T2中止，T1 T3可以执行。

事务中止后，对应的client需要回滚该事务。然后重新运行事务，如果第二次不发生冲突就可以commit了。OCC在冲突很少的情况下性能最高。

**只读事务**

* 初始时 x=0 y=0
* T1: Wx1
  T2: Rx1 Wy2
  T3: Ry2 Rx0
* T3没有看到无效信息，会从本地缓存读取了过期x=0。
* 没有串行顺序可以得到相同的结果，因此对于read-only事务，我们需要也需要进行校验
* 其他OCC算法可以通过版本号避免校验只读事务


**OCC与锁**

如果冲突很少的情况下，OCC比锁的方式要好。因为其可以避免锁住消息，从而使client不需要等待锁。
如果冲突较多，锁比OCC要好。因为OCC会频繁发生事务中止并重新执行，有可能需要重复很多次。而锁只需要等待，不需要重新执行。
例子：
```
locking:
      T1: Rx0 Wx1
      T2: -------Rx1  Wx2
OCC:
      T1: Rx0 Wx1
      T2: Rx0 Wx1
      fast but wrong; must abort one
```

###分布式OCC校验
分布式系统使用OCC需要将存储的数据和校验程序分布到多台服务器上。每个服务器只校验事务中自己的那部分(事务读写该服务器上的数据)，通过事务协调器（TC）管理所有事务，每个client可能会作为自己的TC。TC向每台服务器发出校验请求，若所有服务器返回yes，TC通知服务器commit。这部分是一个二阶段提交。

**分布式系统使用算法1**
如果事务涉及的每台服务器都返回yes（存在等价串行顺序），服务器S1对x进行校验，S2对y（x数据在S1上），对应例2
```
T1: Rx0 Wx1
T2: Rx0 Wy1
T3: Ry0 Rx1
```
S1只校验x的信息：
```
T1: Rx0 Wx1
T2: Rx0
T3: Rx1
```
T2 T1 T3是等价的，因此S1的结果是yes
S2只校验y的信息：
```
T2: Wy1
T3: Ry0
```
T3 T2是等价的，因此S2的结果也是yes
但是我们知道非分布式时是不能commit的。因此算法1在分布式系统中无法正常工作。分布式系统中校验算法必须选择一致的顺序。


**算法2**

思路：client或TC对提交中的事务指定时间戳，类似Thor，取自弱同步时钟（loosely synchronized clocks）作为时间戳。校验程序通过时间戳检查读写顺序的一致性。校验程序通过时间戳指定的顺序进行检查，因此返回yes时意味着事务执行相同的顺序。

使用算法2来看例2：
```
T1@100: Rx0 Wx1 (@后面是时间戳)
T2@110: Rx0 Wy1
T3@105: Ry0 Rx1
```
S1只校验x的信息：
```
T1@100: Rx0 Wx1
T2@110: Rx0
T3@105: Rx1
```
根据时间戳我们只能得出顺序:T1 T3 T2。校验失败，T2应该能够看到x=1（T1写入的）

S2只校验y的信息：
```
T2@110: Wy1
T3@105: Ry0
```
时间戳顺序必须是:T3 T2。校验成功,S1返回no，S2返回yes，TC将会退出并回滚事务。

算法2中，时间戳可以确保不同的校验服务器以相同的顺序进行校验。


使用时间戳顺序的同时也会导致一些问题，例子：
```
T1@100: Rx0 Wx1
T2@50: Rx1 Wx2
```
T2会退出，因为时间戳表明T2先执行，T1应该能够看到x=2。
如果client的时钟差距太大时，先执行T1再执行T2；而T1的client时间比T2的快，那么T1的时间戳要比T2的大，此时的时间戳顺序可能会导致不必要的退出。
算法2的校验程序不会找出一个可串行化的顺序，而仅仅只是检查时间错顺序上读写的一致性。通过时间戳顺序检查时，我们放弃了一些“乐观”。
若时间同步的较为紧密，或者冲突很少的情况下，这不是一个大问题。

算法2的问题：

* commit信息中包含的值可能会很大
* 可以使用向记录加入版本号的方式检查是否后来的事务读到先前事务的写入
* 我们使用时间戳作为对象的版本号，也可以像FaRM一样使用顺序版本号


**算法3**

每个数据库的记录（也包括缓存的记录）都附加最后一次对其进行写操作的事务的时间戳。
之后只需要校验每个读记录操作的时间戳，检查是否可以看到最近的一次写入的版本号。如果是写操作，将数据对象的版本号设置为写入事务的时间戳。

例子：
```
所有值的初始时间戳为0
T1@100: Rx@0 Wx （缓存中的记录也有版本号）
T2@110: Rx@0 Wy
T3@105: Ry@0 Rx@100
```
* 注意：读集合只包含数据对象的版本号，不包括其值；写集合需要包含新的值，但不是用来校验的。
* S1只校验x的信息：
```
T1@100: Rx@0   Wx
T3@105: Rx@100
T2@110: Rx@0
```
* 按时间戳顺序排序，我们检查所有read是否可以看到最近一次写入。T3可以看到T1写入，但T2看不到，因此S1返回no。
* S2只校验y的信息：
```
T3@105: Ry@0
T2@110: Wy
```
* S2返回yes
* 因此算法3会回滚并退出事务。算法3只使用了时间戳和版本号保证了正确性。

算法3只是解决Thor问题的一部分，如果Thor使用版本号，则可以通知校验程序T2读取了x的过期数据副本。

使用版本号代替值时，我们也会遇到一些问题：有可能发生版本号不同但是值相同的问题。例如
```
T1@100: Wx1
T2@110: Wx2
T3@120: Wx1
T4@130: Rx1@100
```
由版本号可知，T4读取了过期的版本号，应该退出。但是T4读取到了正确的值x=1，所以可以不必退出。在实践中这是可用的，许多OCC系统采用了版本号的方法。

每个数据记录使用版本号#可能导致需要过多的存储空间，Thor想要避免使用过多的空间。

**算法4**

* Thor的失效策略：记录中不包含时间戳。
* Thor读取到过期数据是因为之前事务发送的失效信息(写操作完成后需要向client发送失效信息，用于通知client中相关的缓存失效)还未到达client。
* 由于每台client可能没有看到失效信息，Thor服务器需要跟踪这些信息。
* 服务器保存每台服务器的失效集合——“invalid set”；当收到clietn的ACK后删除client的失效集合；如果提交中的事务读取了client上失效集合数据，服务器会强制其退出；如果事务读取到失效信息，client会退出该事务。

失效集合的例子：
```
client C2：
    T2  Rx  client/TC将要发生prepare消息
server S：
    T1写x，校验，提交
    S将x添加到C2的失效集合中
    服务器发生失效信息给C2
    服务器等待C2的确认响应
```
需要考虑三种情况：

* C2发送prepare消息之前，C2收到失效消息：C2将事务T2退出。
* C2发送prepare消息之前，C2收到失效消息：C2将事务T2退出。
* 失效消息丢失或延迟，C2不知道需要将T2退出：S不会收到C2的确认；X依然在S服务器上C2的失效集合中；S针对T2的prepare将会返回no。
因此，Thor的校验算法不使用记录的时间戳来检测过期读。

##性能

* 图5中AOCC是Thor，与ACBL进行比较。ACBL是指client处理非只读事务时，先与server交互获取数据的写锁，再提交事务。

* AOCC（Thor）有更高的吞吐量，因为发送的消息很少，只有commit消息，没有锁消息。

* 写事务的client增多时，Thor的吞吐量会增加。更多的client意味着更多的并行事务，意味着更多的完成。


##结论

* 缓存减少了client/server数据抓取，速度更快
* 分布式OCC避免了client/server的锁阻塞，提高了速度
* loose time sync，弱同步时间帮助服务器校验程序确定顺序。
* 分布式OCC在20年内依然是一个热点。（论文是1995的，现在2016啦）
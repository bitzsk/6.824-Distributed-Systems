# 基础：RPC和多线程
---

###Go语言
本堂课程实验go语言做为编程实现。很多人问为什么:6.824过去使用C++，学生们花费了大量的时间在处理bug上，而不是分布式系统本身。例如：释放了以后还会使用到的对象。
Go语言有以下特性使得我们能够集中到分布式系统的问题上来。

* 类型安全
* 垃圾回收
* 对并发的支持良好
* 对RPC的支持良好
使用Go语言的另一个原因是这一门简单的语言。

###RPC
全称是Remote Procedure Call（远程程序调用）。这是分布式系统机制的一个重要部分，所有的实验都使用了RPC。
RPC的目的是：计算机直接能够更容易的通过网络进行交互。
RPC隐藏了客户端/服务器直接的交互细节，客户端和服务器调用和处理时就像普通的本地程序调用一样。
RPC应用十分广泛。

理想情况下，RPC使得网络交互看起来像是函数调用，
```
客户端：
    z = fn(x, y)
服务器
    fn(x, y) {
      compute
      return z
    }
```
RPC最终要实现的就是这种成都的透明，Go语言的例子可以参照https://golang.org/pkg/net/rpc/

**RPC消息流**
```
 Client             Server
   request--->
               <---response
```

**RPC软件架构**
```
 client app          handlers
    stubs           dispatcher
   RPC lib           RPC lib
     net  ------------ net
```
* client：客户端
* stubs：客户端创建的存根
* dispatcher：服务端的分发程序
* handlers：服务端的处理程序
* RPC lib ：RPC库
* net：网络
客户端发出RPC，创建stubs，供返回后使用。之后调用RPC包发出底层的网络请求。服务器收到网络请求后解析调用RPC包，通过分发器交由相应的处理器处理。处理完成后原路返回，将处理结果返回给客户端的应用。

**细节**

* 调用服务器的哪个函数（即处理器）？
* 信息的编组：将格式化后的数据进行打包。需要注意一些复杂的数据 数组，指针，对象等。Go语言的RPC库非常强大！但有些东西不能传递，如管道，函数。
* 绑定：Clients如何知道与谁交互？可以向Clients提供主机名。也可以提供一个服务映射表，将服务映射到服务器主机上。
* 多线程：Clients可能有多个线程，可能有大于1个未完成的调用，这时需要匹配返回。服务器端的处理函数可能很慢，因此服务器经常将处理函数运行在多个线程中。

**错误处理**
RPC过程中，若发生了错误怎么办？比如：丢包，网络连接失败，服务器速度慢，服务器崩溃等等。

RPC失败看起来像是Client的RPC库发生了错误。但并不一定是哪里发生了异常。这是因为有时Client没有从服务器收到返回；有时Client 不知道服务器是否有返回！有时可能服务器或网络在传递时发送了错误。

***最简单的策略：多次发送请求***

* RPC库等待响应一定时间
* 如果没有收到返回，重新发送请求
* 还未收到，重复几次
* 仍然未收到，返回错误

Q：多次请求是否很容易处理错误？
很容易的多次写问题：比如client发送“从银行账户中扣除10美元”

Q：client编程中可能遇到的问题？
Put("k",10)- RPC 将设置数据库中key的值
Put("k", 20) - client再次设置相同的key
这时会发生一些问题：超时、重复发送、先发后至等。

Q：多次发送总是可以吗？
两种情况下是：
如果是重复操作，如只读；
如果应用程序有自己的应对重复写入/的策略

***更好的策略：只发送一次请求***
思路：服务器的RPC代码检测到多次请求，返回之前的请求，并且不会重新调用handler。

Q:如何检测重复请求？
client的每一次请求都包含唯一的XID，重复的请求中有相同的XID
服务器端：
```
if seen[xid]:
    r = old[xid]
else
    r = handler()
    old[xid] = r
    seen[xid] = true
```

* 只发送一次的复杂性：（实验2中会遇到）
    *  如何保证XID唯一？ 大的随机数字，将唯一的client id(可使用ip地址)和序号组合起来。
    *  服务器最终必须丢弃旧的RPC信息，需要考虑的是，何时丢弃是安全的？理想情况下，client有唯一的id，每个client RPC请求有序列号。client每次请求时查看所有的回复是否<=X；或者client每次只允许有一个未完成的RPC，当seq+1返回后，运行服务器丢弃所有<=seq的消息；或者client保持小于5分钟重试时间，5分钟后丢弃。
    *  初始请求仍在执行中，如何处理重复的请求？服务器此时不知道重复了，因为handler()未执行完，old[xid] = r也未执行。此时，可以设置在RPC执行期间设置等待标志位，重复的请求等待或者忽略。

* 若只执行一次的服务器程序崩溃或者重启时，如何处理？可以将副本写入磁盘，也可以使用副本服务器
* 正好一次策略怎么？正好一次即：最多一次加无限重试和容错服务（实验3）
        
**Go语言的RPC错误处理**

Go语言的RPC是“最多一次”。

* 打开TCP连接
* 将请求写入TCP连接
* TCP可能重传传播，但是服务器的TCP会过滤掉重复信息
* Go代码中没有重试（例如，不会创建第二个TCP连接）
* Go的RPC代码在未收到服务器返回时会返回错误。（这种情况可能是由于TCP超时；或服务器未看到请求；或者服务器处理了请求，但是服务器或网络在回复之前崩溃）

实验一中Go语言中RPC的“最多一次”不能检测重复

* 只能应用于单一的RPC调用
* 若worker没有响应，master重新发送到其他worker，但初次的worker可能挂了也可能在运行中。
* Go的RPC不能检测这种重复的情况：


###多线程
多线程是基本的服务器构建工具，在实验中会多次使用到。多线程比较复杂，对RPC来说很有用。
在Go语言中，Goroutine是一个通过go关键字起起来的独立的执行某个function的过程，它拥有独立的可以自行管理的调用栈。

**线程=线程控制**
多线程使得一个程序同时做很多事情，这些线程共享内存空间，每个线程包含自己的线程状态：程序计数器、寄存器和栈。

**多线程带来的挑战**

* 共享数据：两个线程在同一时刻修改相同的变量；一个线程读取了另一个线程正在修改的数据。这些问题通常叫做“互斥”。因此，多线程需要保护共享数据的不变性。Go语言可通过sync.Mutex实现。
* 协调多个线程：例如需要等待多个线程完成，即“同步”，Go语言通过channels实现。
* 死锁：线程1等待线程2，同时线程2等待线程1
* 锁粒度：
    * 粗粒：简单，但很少并发/并行
    * 细粒度：更多的并发、互斥和死锁

下面通过labrpc的RPC包说明这些问题：
labrpc.go
该程序类似Go的RPC系统，只是网络系统是模拟的。模拟网络的可以延迟请求和回复，丢失请求和回复，重新排序请求和回复等。程序的内容很典型说明了多线程、互斥和同步相关概念。

程序结构：

* struct Network
描述网络，包括服务器和客户端，以及网络的互斥。
* RPC概览
    * test_test.go中有很多例子。如TestBasic()
    * 应用调用Call()
reply := end.Call("Raft.AppendEntries", args, &reply) 发送一个RPC,等待返回。
    * 服务器端：
    srv := MakeServer()
    srv.AddService(svc) -- 服务器可以有多个服务，如k/v通过srv传递给net.AddServer()
    svc := MakeService(receiverObject) 
-- 对象的方法会处理RPC 就像rpcs.Register()，将svc传递给srv.AddService()

* struct Server
一个支持多个服务的服务器
    * AddService 添加一个服务名
    * Dispatch 分发一个请求到正确到服务
    * Call(): 使用反射找到参数的类型，使用gob组装参数；e.ch是网络同步发送请求的channel；创建channel同步地从网络获取返回。
    * MakeEnd():有一个线程和goroutine模拟网络；读取e.ch并处理请求。每个请求在单独的goroutine处理
    * ProcessReq():找出服务器的endpoint。如果网络不可用，可能延迟或丢弃请求；将请求分发到一个新线程执行服务。
    * Service.dispatch():查找请求的方法；解组参数，调用方法，组装响应，返回响应。
    
Go语言的内存模型需要负载的同步进行交互。
```
var x int
done := false
go func() { x = f(...); done = true }
while done == false { }
```
上述代码不正确，


学习Go的goroutines and channels机制
  使用Go的冲突检测:
    https://golang.org/doc/articles/race_detector.html
    go test --race mypkg

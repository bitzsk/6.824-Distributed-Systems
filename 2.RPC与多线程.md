# 基础：RPC和多线程
---

###Go语言
本课程的实验采用Go做为编程语言。很多人问为什么不使用其他语言？6.824过去一直使用C++，这导致学生们花费了大量的时间用于处理bug，而不是分布式系统本身的特性上。例如：C++程序经常释放了以后还会使用到的对象。

Go语言有以下特性使得我们能够集中到分布式系统的问题上来。

* 类型安全
* 垃圾回收
* 对并发的支持良好
* 对RPC的支持良好
使用Go语言的另一个原因是这一门简单的语言。

###RPC
全称是Remote Procedure Call（远程程序调用）。这是分布式系统机制的一个重要部分，所有的实验都使用了RPC。
RPC的目的是：计算机之间能够更容易的通过网络进行交互。
RPC隐藏了客户端/服务器之间的交互细节，使得两者之间互相调用和处理类似普通的本地程序相互调用一样。
RPC在分布式系统中有十分广泛的应用。

理想情况下，RPC使得网络交互看起来像是函数调用，
```
客户端：
    z = fn(x, y)
服务器
    fn(x, y) {
      compute
      return z
    }
```
观察上面的程序，RPC最终要实现的就是这种程度的透明，Go语言的例子可以参照https://golang.org/pkg/net/rpc/

**RPC消息流**
```
 Client             Server
   request--->
               <---response
```

**RPC软件架构**
```
 client app          handlers
    stubs           dispatcher
   RPC lib           RPC lib
     net  ------------ net
```
* client：客户端
* stubs：客户端创建的存根
* dispatcher：服务端的分发程序
* handlers：服务端的处理程序
* RPC lib ：RPC库
* net：网络
客户端发出RPC，创建stubs，供返回后使用。之后调用RPC库发出底层的网络请求。服务器收到网络请求后解析调用RPC包，通过分发器交由相应的处理器处理。处理完成后原路返回，将处理结果返回给客户端的应用。

**细节**

* 调用服务器的哪个函数（即处理函数handler）？
* 信息的编组：将格式化后的数据进行打包。需要注意的是一些复杂的数据如：数组，指针，对象等。Go语言的RPC库非常强大！但有些类型不能传递，如管道，函数。
* 绑定：Clients如何知道与谁交互？我们可以向Clients提供主机名，也可以提供一个服务映射表，将服务映射到服务器主机上。
* 多线程：Clients可能有多个线程同时进行RPC，因此某个时刻可能有多于1个未完成的调用，这时需要正确匹配返回。而服务器端的处理函数可能很慢，因此服务器经常将处理函数运行在多个线程中。

**错误处理**
RPC过程中，若发生了错误怎么办？比如：丢包，网络连接失败，服务器速度慢，服务器崩溃等等。

RPC的失败看起来像是Client的RPC库发生了错误，但我们并不一定知道是哪里发生了异常。这是因为有时Client没有从服务器收到返回；有时Client 不知道服务器是否有返回！有时可能服务器或网络在传递过程中发送了错误。这些都可能导致client的RPC失败。

***最简单的策略：多次发送请求***

* RPC库等待响应一定时间
* 如果没有收到返回，重新发送请求
* 还未收到，重复几次
* 仍然未收到，返回错误

Q：多次请求有一个很简单的问题：
很容易造成多次写问题：比如client多次发送“从银行账户中扣除10美元”

Q：client编程中可能遇到的错误？
Put("k",10)- RPC 将设置数据库中key的值
Put("k", 20) - client再次设置相同的key
这时会发生一些问题：超时、重复发送、先发后至等。

Q：多次发送总是靠谱的吗？
两种情况下是：

* 如果是重复操作，如只读
* 如果应用程序有自己的应对重复写入/的策略（实验一需要应对并处理）

***更好的策略：只发送一次请求***
思路：服务器的RPC代码检测到多次请求，返回上一个请求对应回复，并且不重新运行handler。

Q:如何检测重复请求？
client的每一次请求都包含唯一的XID，若是重复的请求，则包含相同的XID
服务器端：
```
if seen[xid]:
    r = old[xid]
else
    r = handler()
    old[xid] = r
    seen[xid] = true
```

* 只发送一次的复杂性：（实验2中会遇到）
    *  如何保证XID唯一？ 可以采用大的随机数字，将唯一的client id(可使用ip地址)和序号组合起来。
    *  服务器最终必须丢弃旧的RPC信息，需要考虑的是，何时丢弃是安全的？理想情况下，client有唯一的id，每个client RPC请求有序列号，将两者通过#组合起来使用。
    *  client每次请求时，服务器查看所有序号<=X的回复；或者只允许client某个时刻有一个未完成的RPC，当收到seq+1返回后才允许服务器丢弃所有<=seq的消息；或者client保持小于5分钟重试时间，5分钟后丢弃。
    *  某个请求仍在执行中时，如何处理重复的请求？服务器此时不知道重复了，因为handler()未执行完，`old[xid] = r`也未执行。此时，可以在RPC执行期间设置等待标志位，重复的请求需要等待或者忽略。

* 若只执行一次的服务器程序崩溃或者重启时，如何处理？可以将副本写入磁盘，也可以使用副本服务器
* “正好一次”策略怎么样？正好一次即：最多一次加无限重试和容错服务（实验3）
        
**Go语言的RPC错误处理**

Go语言的RPC是“最多一次”。

* 打开TCP连接
* 将请求写入TCP连接
* TCP可能重复传递，但是服务器的TCP会过滤掉重复信息
* Go语言中不会重试（例如，不会创建第二个TCP连接）
* Go的RPC代码在未收到服务器返回时会返回错误。（这种情况可能是由于TCP超时；或服务器未收到请求；或者服务器处理了请求，但是服务器或网络在回复成功之前崩溃）

只有Go语言的RPC所实现的“最多一次”策略，对于实验1来说是远远不够的，因为：

* 其只能应用于单一的RPC调用
* 若worker没有响应，master重新发送到其他worker，但初次的worker可能处于崩溃状态，也可能在运行中。
* Go的RPC不能检测重复的情况：
    * 实验1中没有问题，应用程序会处理重复的情况
    * 实验2中会明确的对重复情况进行处理

###多线程
多线程是服务器的基础构建工具，在实验中会多次使用到。多线程对RPC来说很有用，但使用起来比较复杂。
Go语言的多线程被称为`Goroutine`。

**多线程=对线程的控制**
多线程允许一个程序同时做很多事情，这些线程共享内存空间，每个线程包含自己的线程状态：程序计数器、寄存器和栈。

**多线程带来的挑战**

* 共享数据：两个线程在同一时刻修改相同的变量；一个线程读取了另一个线程正在修改的数据。这些问题通常叫做“互斥”。因此，多线程需要保护共享数据的不变性。Go语言通过sync.Mutex实现。
* 协调多个线程：例如需要等待多个线程完成，即“同步”，Go语言通过channels实现。
* 死锁：线程1等待线程2，同时线程2等待线程1
* 锁粒度：
    * 粗粒：简单，但很少并发/并行
    * 细粒度：更多的并发、互斥和死锁

下面通过labrpc的RPC包说明这些问题：
labrpc.go
该程序类似Go的RPC系统，只是网络系统是模拟的。模拟的网络系统可以模拟延迟请求和回复，网络丢失请求和回复，重新排序请求和回复等等异常状况。程序的内容很典型地说明了多线程、互斥和同步等相关概念。

程序结构：

* struct Network
描述网络，包括服务器和客户端，以及网络的互斥。
* RPC概览
    * test_test.go中有很多例子。如TestBasic()
    * 应用调用Call()
reply := end.Call("Raft.AppendEntries", args, &reply) 发送一个RPC,等待返回。
    * 服务器端：
    srv := MakeServer()
    srv.AddService(svc) -- 服务器可以有多个服务，如k/v通过srv传递给net.AddServer()
    svc := MakeService(receiverObject) 
-- 对象的方法会处理RPC 就像rpcs.Register()，将svc传递给srv.AddService()

* struct Server
一个支持多个服务的服务器
    * AddService 添加一个服务名
    * Dispatch 分发一个请求到正确到服务
    * Call(): 使用反射找到参数的类型，使用gob组装参数；e.ch是网络同步发送请求的channel；创建channel同步地从网络获取返回。
    * MakeEnd():有一个线程和goroutine模拟网络；读取e.ch并处理请求。每个请求在单独的goroutine处理
    * ProcessReq():找出服务器的endpoint。如果网络不可用，可能延迟或丢弃请求；将请求分发到一个新线程执行服务。
    * Service.dispatch():查找请求的方法；解组参数，调用方法，组装响应，返回响应。
    
Go语言的内存模型要求通过同步进行交互。下面的代码不正确的：
```
var x int
done := false
go func() { x = f(...); done = true }
while done == false { }
```


学习Go的goroutines and channels机制
  使用Go的冲突检测:
    https://golang.org/doc/articles/race_detector.html
    go test --race mypkg
